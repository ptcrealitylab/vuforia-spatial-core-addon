<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Import the Envelope Container APIs -->
    <script src="objectDefaultFiles/envelope.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/THREE.MeshLine.js"></script>
    <script src="thirdPartyCode/graph.js"></script>
    <script src="js/pathfinding.js"></script>
    <script src="js/splineRendering.js"></script>
    <script src="objectDefaultFiles/gl-worker.js"></script>
    <link rel="stylesheet" href="styles/styles.css">
    <meta charset="UTF-8">
    <title>Path</title>
</head>

<body>
<!-- Create a rootElementWhenOpen with the UI that shows when it is in fullscreen 2D mode -->
<div id="rootElementWhenOpen">
    <canvas id="canvas"></canvas>
</div>
<!-- Create a rootElementWhenClosed with the UI that shows when it minimized into an icon -->
<div id="rootElementWhenClosed">
    <div id="close">
        <img id="bigIcon" src="resources/large-icon.svg" width="300px" height="300px">
        <img id="graphics" src="resources/pathfinding-icon.svg" width="300px" height="300px">
        <div id="details">
            <img id="detailsIcon" src="resources/icon-extension.svg" width="858px" height="300px">
            <div id="mainDetailText">UN-NAMED PATH</div>
            <div id="subDetailText">0 POINTS OF INTEREST</div>
            <img id="editNameIcon" src="resources/pencil-icon-107.svg" width="42px" height="46px">
        </div>
    </div>
    <div id="far">
        <img id="smallIcon" src="resources/small-icon.svg" width="100px" height="100px">
    </div>
</div>
</body>
<script>

    /******** THREEJS ********/

    let realRenderer, renderer;
    let spatialInterface;
    let camera, scene, splineRenderer, cube;
    let mainContainerObj, groundPlaneContainerObj;
    let isProjectionMatrixSet = false, isGroundPlaneTracked = false;

    let rendererWidth = screen.height; // width is height because landscape orientation
    let rendererHeight = screen.width; // height is width
    var aspectRatio = rendererWidth / rendererHeight;

    // Variable to store information to send to the server
    let pathData = {
        index: 0,
        checkpoints: []
    };

    // 11. This is just a helper function to set a three.js matrix using an array
    function setMatrixFromArray(matrix, array) {
        matrix.set( array[0], array[4], array[8], array[12],
            array[1], array[5], array[9], array[13],
            array[2], array[6], array[10], array[14],
            array[3], array[7], array[11], array[15]);
    }

    window.addEventListener('load', function() {
        if (!spatialInterface) {
            spatialInterface = new SpatialInterface();
        }
        spatialInterface.useWebGlWorker();
    });

    function main() {
        realRenderer = new THREE.WebGLRenderer( { alpha: true } );
        realRenderer.setPixelRatio( window.devicePixelRatio );
        realRenderer.setSize( rendererWidth, rendererHeight );
        // document.body.appendChild( realRenderer.domElement );
        realGl = realRenderer.getContext();

        // create a fullscreen webgl renderer for the threejs content and add to the dom
        renderer = new THREE.WebGLRenderer( { context: gl, alpha: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( rendererWidth, rendererHeight );
        document.body.appendChild( renderer.domElement );

        // create a threejs camera and scene
        camera = new THREE.PerspectiveCamera( 70, aspectRatio, 1, 1000 );
        scene = new THREE.Scene();

        mainContainerObj = new THREE.Object3D();
        mainContainerObj.matrixAutoUpdate = false;
        scene.add(mainContainerObj);

        groundPlaneContainerObj = new THREE.Object3D();
        groundPlaneContainerObj.matrixAutoUpdate = false;
        scene.add(groundPlaneContainerObj);

        console.log('add cube');
        /*var geometrycube = new THREE.BoxGeometry( 10, 10, 10 );
        var material = new THREE.MeshBasicMaterial( {color: 0xffffff} );
        cube = new THREE.Mesh( geometrycube, material );
        groundPlaneContainerObj.add( cube );
        cube.position.set(0,0,0);

        const materialcube_x = new THREE.MeshBasicMaterial( {color: 0xff0000} ); // x - red
        let dummy_x = new THREE.Mesh( geometrycube, materialcube_x );
        groundPlaneContainerObj.add(dummy_x);
        dummy_x.position.set(20,0,0);

        const materialcube_z = new THREE.MeshBasicMaterial( {color: 0x0000ff} ); // z - blue
        let dummy_z = new THREE.Mesh( geometrycube, materialcube_z );
        groundPlaneContainerObj.add(dummy_z);
        dummy_z.position.set(0,0,20);

        const materialcube_y = new THREE.MeshBasicMaterial( {color: 0x00ff00} ); // y - green
        let dummy_y = new THREE.Mesh( geometrycube, materialcube_y );
        groundPlaneContainerObj.add(dummy_y);
        dummy_y.position.set(0,20,0);*/

        splineRenderer = new SplineRender(groundPlaneContainerObj);

    }



    /****** ******/

    if (!spatialInterface) {
        spatialInterface = new SpatialInterface();
    }

    // Define a list of the names of tools that can go inside this envelope
    let compatibleToolTypes = ['pathPoint'];

    let rootElementWhenOpen = document.getElementById('rootElementWhenOpen');
    let rootElementWhenClosed = document.getElementById('rootElementWhenClosed');
    let canvas = document.getElementById('canvas');

    let smallIcon = document.getElementById('smallIcon');
    let bigIcon = document.getElementById('bigIcon');
    let graphics = document.getElementById('graphics');
    let details = document.getElementById('details');
    let mainDetailText = document.getElementById('mainDetailText');
    let subDetailText = document.getElementById('subDetailText');
    let editNameIcon = document.getElementById('editNameIcon');

    let screenWidth = 812;
    let screenHeight = 375; // TODO: get via API

    spatialInterface.getScreenDimensions(function(width, height) {
         screenWidth = width;
         screenHeight = height;
         canvas.width = screenWidth + 'px';
         canvas.height = screenHeight + 'px';
         canvas.style.width = screenWidth + 'px';
         canvas.style.height = screenHeight + 'px';
    });

    let defaultName = 'UN-NAMED PATH';
    let name = defaultName;

    let areFramesOrdered = true;
    let isStackable = false;

    // Designate this tool as an envelope by, automatically enabling all the associated features
    let envelope = new Envelope(spatialInterface, compatibleToolTypes, rootElementWhenOpen, rootElementWhenClosed, isStackable, areFramesOrdered);

    // The pathfinder object maintains a graph composed of points of interest and obstacles and computes shortest paths
    let pathfinder = new Pathfinder();
    const CAMERA_ID = 'CAMERA';
    pathfinder.addPointOfInterest(CAMERA_ID);

    let targetedPointOfInterest = null;
    let distancesToCenter = {};

    let shouldRender = false;

    let THRESHOLD_VERY_CLOSE = 600; // less than 500 = close
    let THRESHOLD_CLOSE = 1600; // less than 1000 = medium
    // anything bigger than this is considered far
    // if you want another level, try 2400 for veryFar

    let DISTANCES = Object.freeze({
        veryClose: 'veryClose',
        close: 'close',
        far: 'far'
    });

    let currentDistance = DISTANCES.close;

    spatialInterface.onRealityInterfaceLoaded(function() {

        spatialInterface.addMatrixListener(function(modelView, _projection) {
            if (!camera || !mainContainerObj) {
                return;
            }

            var scaleFactor = Math.abs(modelView[0]);
            var zDistance = Math.abs(modelView[14]);

            let scaledDistance = zDistance/scaleFactor;

            if (scaledDistance < THRESHOLD_VERY_CLOSE) {
                renderIcon(DISTANCES.veryClose);
            } else if (scaledDistance < THRESHOLD_CLOSE) {
                renderIcon(DISTANCES.close);
            } else {
                renderIcon(DISTANCES.far);
            }


            // 9. only set the projection matrix for the camera 1 time, since it stays the same
            if (!isProjectionMatrixSet && _projection.length > 0) {

                setMatrixFromArray(camera.projectionMatrix, _projection);
                isProjectionMatrixSet = true;
            }

            // 10. Every frame, set the position of the containerObj to the modelViewMatrix
            if (isProjectionMatrixSet && envelope.isOpen) {
                setMatrixFromArray(mainContainerObj.matrix, modelView);
            }
            mainContainerObj.visible = envelope.isOpen;


        });

        spatialInterface.addGroundPlaneMatrixListener(function(groundPlaneMatrix, projectionMatrix) {

            if (isProjectionMatrixSet) {                                                // don't turn into else statement, both can happen

                setMatrixFromArray(groundPlaneContainerObj.matrix, groundPlaneMatrix);  // update model view matrix
                groundPlaneContainerObj.visible = true;

                if (!isGroundPlaneTracked) console.log('surface tracked');
                isGroundPlaneTracked = true;

                // Update Camera node position:

                let groundPlaneCoordinates = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);    // world coordinates
                groundPlaneContainerObj.worldToLocal(groundPlaneCoordinates);   // convert to ground plane coordinates

                pathfinder.updateNodePosition(CAMERA_ID, groundPlaneCoordinates.x, groundPlaneCoordinates.z, 0);    // Update camera node position

            }

        });
    });



    function renderIcon(distance, forceRender) {
        if (distance === currentDistance && !forceRender) { return; } // don't re-render redundantly

        currentDistance = distance;

        if (distance === DISTANCES.close || distance === DISTANCES.veryClose) {
            if (distance === DISTANCES.veryClose) {
                // render a preview with info related to what's inside
                if (!bigIcon.classList.contains('extraBig')) {
                    bigIcon.classList.add('extraBig');
                }

                if (details.classList.contains('fadeoutDetails')) {
                    details.classList.remove('fadeoutDetails');
                }

                mainDetailText.textContent = name.toUpperCase();
                let fontSize = 42; // pixels
                if (name.length > 9) { // (max width = 42 * 9 = 378) => (W = 42 * length) => (378/length = fontSize)
                    fontSize = (42 * 9) / name.length;
                }
                mainDetailText.style.fontSize = fontSize + 'px';

                let numPointsOfInterest = (pathfinder.pointsOfInterest.length-1);
                let plural = numPointsOfInterest === 1 ? '' : 'S';
                subDetailText.textContent = numPointsOfInterest + ' POINT' + plural + ' OF INTEREST';
            } else {
                if (bigIcon.classList.contains('extraBig')) {
                    bigIcon.classList.remove('extraBig');
                }

                if (!details.classList.contains('fadeoutDetails')) {
                    details.classList.add('fadeoutDetails');
                }
            }

            // render the hexagon icon with details
            if (!smallIcon.classList.contains('fadeoutSmallIcon')) {
                smallIcon.classList.add('fadeoutSmallIcon');
            }

            if (bigIcon.classList.contains('fadeoutBigIcon')) {
                bigIcon.classList.remove('fadeoutBigIcon');
                graphics.classList.remove('fadeoutGraphics');
            }

        } else if (distance === DISTANCES.far) {
            // render a small hexagon
            if (smallIcon.classList.contains('fadeoutSmallIcon')) {
                smallIcon.classList.remove('fadeoutSmallIcon');
            }

            if (!bigIcon.classList.contains('fadeoutBigIcon')) {
                bigIcon.classList.add('fadeoutBigIcon');
                graphics.classList.add('fadeoutGraphics');
            }

            if (bigIcon.classList.contains('extraBig')) {
                bigIcon.classList.remove('extraBig');
            }

            if (!details.classList.contains('fadeoutDetails')) {
                details.classList.add('fadeoutDetails');
            }
        }
    }

    let isListeningForKeyboard = false;

    function onKeyUp(e) {
        if (!isListeningForKeyboard) { return; }

        var isCharacter = !!e.key.match(/^[a-zA-Z0-9]$/);

        if (isCharacter) {
            name = name + e.key;
        } else {
            if (e.key === "Backspace") {
                name = name.slice(0, -1); // remove last character
            } else if (e.key === " ") {
                name = name + "\u00a0"; // special space character doesn't get escaped
                // resetScroll();
                // setTimeout(function() {
                //     resetScroll(); // also do it after a slight delay
                // }, 100);
            }
        }

        renderIcon(currentDistance, true);

        // resizeText();
        spatialInterface.writePublicData("storage", "name",  name);
    }

    spatialInterface.onKeyboardClosed(function() {
        isListeningForKeyboard = false; // stop listening once the keyboard closes
        if (name === '') {
            name = defaultName;
            renderIcon(currentDistance, true);
        }
    });

    spatialInterface.addReadPublicDataListener('storage', "name", function (e) {
        if (typeof e === 'string') {
            name = e;
            if (name === '') {
                name = defaultName;
            }
            renderIcon(currentDistance, true);
        }
    });

    spatialInterface.onKeyUp(onKeyUp);

    let wasClosedIconPressed = false;
    rootElementWhenClosed.addEventListener('pointerdown', function(e) {
        wasClosedIconPressed = true;
    });

    // Add a touch event that opens up the envelope into fullscreen mode when the icon is tapped
    rootElementWhenClosed.addEventListener('pointerup', function(e) {

        console.log('pointer up');

        if (currentDistance === DISTANCES.close || currentDistance === DISTANCES.veryClose) {

            console.log('close pointer');

            // if overlapping pencil icon
            let pencilRect = editNameIcon.getClientRects()[0];
            if (e.pageX > pencilRect.left && e.pageX < pencilRect.right &&
                e.pageY > pencilRect.top && e.pageY < pencilRect.bottom) {
                console.log('edit name');

                isListeningForKeyboard = true;

                if (name === defaultName) {
                    name = '';
                    renderIcon(currentDistance, true);
                }

                spatialInterface.openKeyboard();

            } else {

                if (wasClosedIconPressed) {
                    console.log('open!');
                    envelope.open();
                }
            }
        }

        wasClosedIconPressed = false;
    });

    envelope.onClose(function() {
        spatialInterface.setStickinessOff();
        document.getElementById('canvas').style.display = 'none';
    });

    envelope.onOpen(function() {
        spatialInterface.setStickyFullScreenOn();
        document.getElementById('canvas').style.display = '';
    });

    // This is the "onload" for the envelope - inside this, containedFrames will be correct
    envelope.onPublicDataLoaded(function() {

        // Subscribe to positions of all contained tools
        envelope.forEachFrame(function(frameId, frameData) {
            subscribeToFramePosition(frameId, frameData);

            if (frameData.type === 'pathPoint') {
                pathfinder.addPointOfInterest(frameId);
                renderIcon(currentDistance, true);
            }
        });
    });

    // Subscribe to the positions of any new frames as they get added
    // {objectId: string, frameId: string, frameType: string}
    envelope.onFrameAdded(function(frameAddedMessage) {

        let frameId = frameAddedMessage.frameId;
        let frameData = envelope.containedFrames[frameId];
        subscribeToFramePosition(frameId, frameData);

        if (frameData.type === 'pathPoint') {

            pathfinder.addPointOfInterest(frameId);
            renderIcon(currentDistance, true);

            // Add checkpoint tool to path
            // pathData.checkpoints.push({
            //     "name" : this.selectedCheckpoint.name,
            //     "active" : 0,                               // If set to 1, the robot will change state to executing mission to get to this checkpoint
            //     "posX" : this.selectedCheckpoint.position.x,
            //     "posY" : this.selectedCheckpoint.position.y,
            //     "posZ" : this.selectedCheckpoint.position.z,
            //     "orientation" : this.selectedCheckpoint.getOrientation() // orientation of the footprint
            // });

        }
    });

    envelope.onFrameDeleted(function(frameDeletedMessage) {
        let frameId = frameDeletedMessage.frameId;
        let frameType = frameDeletedMessage.frameType;
        if (frameType === 'pathPoint') {
            pathfinder.removePointOfInterest(frameId);
            renderIcon(currentDistance, true);
        }
    });

    // TODO: figure out if I need to properly unsubscribe or not... maybe not?
    // {objectId: string, frameId: string, frameType: string}
    // envelope.onFrameDeleted(function(frameDeletedMessage) { });

    function subscribeToFramePosition(frameId, frameData) {
        console.log('subscribe to position of ' + frameId + ' (type = ' + frameData.type + ')');

        let shouldSubscribe3d = true;
        envelope.subscribeToPosition(frameId, function(centerX, centerY, displayWidth, displayHeight, centerZ, displayDepth, worldCoordinates) {
            if (!envelope.isOpen) { return; } // don't waste time computing paths and rendering if not open

            let avgDimension = (displayWidth+displayHeight)/2;

            //pathfinder.updateNodePosition(frameId, centerX, centerY, centerZ);
            //pathfinder.updateNodeRadius(frameId, avgDimension/2);

            let groundPlaneCoordinates = new THREE.Vector3(worldCoordinates.position.x, worldCoordinates.position.y, worldCoordinates.position.z);
            groundPlaneContainerObj.worldToLocal(groundPlaneCoordinates);   // convert to ground plane coordinates

            //pathfinder.updateNodePosition(frameId, worldCoordinates.position.x, worldCoordinates.position.y, worldCoordinates.position.z);

            pathfinder.updateNodePosition(frameId, groundPlaneCoordinates.x, groundPlaneCoordinates.z, 0);
            pathfinder.updateNodeRadius(frameId, 50); // consider scale to be homogeneous

            if (frameData.type === 'pathPoint') {
                let distanceToCenterOfScreen = {
                    x: Math.abs(centerX - screenWidth/2),
                    y: Math.abs(centerY - screenHeight/2),
                    z: centerZ
                };
                distancesToCenter[frameId] = distanceToCenterOfScreen;
            }

            shouldRender = true;
        }, shouldSubscribe3d);
    }

    render = function() {
        if (!shouldRender) {
            return;
        }

        try {

            // send a message to the frame that is closest to the center of the screen
            highlightTargetedFrame();

            let allShortestPaths = {};
            let edgesInAnyShortestPath = {};
            let edgesInTargetedPath = {};
            allShortestPaths[CAMERA_ID] = {};

            let pathPoints = {};

            let index = 0;
            let previousNode = null;
            let positions = [];

            console.log('How many POI: ', pathfinder.pointsOfInterest.length);

            // compute the path from the CAMERA to each point-of-interest tool and draw lines along the "edges" between each of the "nodes" on the path
            pathfinder.pointsOfInterest.forEach(function(nodeB) {
                if (nodeB.id === CAMERA_ID) {
                    //console.log('This is camera, return');
                    return;
                } // don't draw line to self

                let thisPath, newPos;

                if (index === 0){
                    // actually compute the path from the CAMERA to the green circle using the pathfinder's computeShortestPath method
                    thisPath = pathfinder.computeShortestPath(CAMERA_ID, nodeB.id);
                    //allShortestPaths[CAMERA_ID][nodeB.id] = thisPath;

                    // Camera position = nodeA in first edge
                    newPos = new THREE.Vector3(thisPath.edges[0].nodeA.x, thisPath.edges[0].nodeA.y, thisPath.edges[0].nodeA.z);
                    positions = [newPos];

                } else {

                    thisPath = pathfinder.computeShortestPath(previousNode.id, nodeB.id);
                    //allShortestPaths[previousNode.id][nodeB.id] = thisPath;

                }

                // render the path
                thisPath.edges.forEach(function(edge) {

                    // by default each edge is a transparent blue
                    edgesInAnyShortestPath[edge.id] = edge; // not necessary for this demo, but storing this for old demo

                    if (nodeB.id === targetedPointOfInterest) {
                        // if the tool is the "target" one, highlight the line
                        edgesInTargetedPath[edge.id] = edge; // not necessary for this demo, but storing this for old demo

                    }

                    newPos = new THREE.Vector3(edge.nodeB.x, edge.nodeB.y, edge.nodeB.z);
                    positions.push(newPos);

                });

                //console.log('NODE: ', nodeB.id, ' | positions: ', positions);

                previousNode = nodeB;
                index++;

            });

            splineRenderer.updateSpline(CAMERA_ID, positions);


            shouldRender = false;
        } catch (e) {
            console.error('error in render function', e);
        }

        if (isProjectionMatrixSet && envelope.isOpen) {
            renderer.render(scene, camera);
        }
    }

    function highlightTargetedFrame() {
        // determine if targeted PoI has changed
        let closestDistanceToCenter = {
            frameId: null,
            distance: 1000000000,
            zPos: 0
        };

        for (let frameId in distancesToCenter) {

            let distanceInfo = distancesToCenter[frameId];

            //console.log('FRAME DISTANCE: ', frameId, distanceInfo);

            let distance = Math.sqrt(distanceInfo.x * distanceInfo.x + distanceInfo.y * distanceInfo.y);

            if (distance < closestDistanceToCenter.distance) {
                closestDistanceToCenter.frameId = frameId;
                closestDistanceToCenter.distance = distance;
                closestDistanceToCenter.zPos = distanceInfo.z
            }
        }

        if (closestDistanceToCenter.frameId && closestDistanceToCenter.frameId !== targetedPointOfInterest) {

            // send message to previous target (if any) to un-highlight
            if (targetedPointOfInterest) {

                splineRenderer.highlightSpline(targetedPointOfInterest, false);
                envelope.sendMessageToFrameWithId(targetedPointOfInterest, {
                    highlightTarget: false
                });
            }

            targetedPointOfInterest = closestDistanceToCenter.frameId;

            splineRenderer.highlightSpline(targetedPointOfInterest, true);

            // send message to new target to highlight
            envelope.sendMessageToFrameWithId(targetedPointOfInterest, {
                highlightTarget: true
            });
        }
        distancesToCenter = {};
    }

</script>
</html>
