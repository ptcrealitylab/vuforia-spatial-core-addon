<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>THREE.js Sphere</title>
    <script src="objectDefaultFiles/object.js"></script>
    <script src="objectDefaultFiles/pep.min.js"></script>
    <script src="resources/threejs-src/2016/three.min.js"></script>
</head>
<body>
<script>
    var camera, scene, renderer;
    var threejsContainerObj;
    var realityInterface;
    var mesh;
    var isProjectionMatrixSet = false;
    var rendererWidth = screen.height;
    var rendererHeight = screen.width;
    var aspectRatio = rendererWidth / rendererHeight;
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();

    window.addEventListener('load', function() {
        // create a fullscreen webgl renderer for the threejs content and add to the dom
        renderer = new THREE.WebGLRenderer( { alpha: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( rendererWidth, rendererHeight );
        document.body.appendChild( renderer.domElement );

        // create a threejs camera and scene
        camera = new THREE.PerspectiveCamera( 70, aspectRatio, 1, 1000 );
        scene = new THREE.Scene();

        threejsContainerObj = new THREE.Object3D();
        threejsContainerObj.matrixAutoUpdate = false;
        scene.add(threejsContainerObj);

        var ambLight = new THREE.AmbientLight(0x404040);
        scene.add(ambLight);
        
        createMesh();

        // make the frame fullscreen within the reality editor,
        // and subscribe to the modelview and projection matrices
        realityInterface = new RealityInterface();
        
        realityInterface.onRealityInterfaceLoaded(function() {

            realityInterface.getScreenDimensions(function(width, height) {
                document.body.width = width + 'px';
                document.body.height = height + 'px';
                rendererWidth = width;
                rendererHeight = height;
                renderer.setSize( rendererWidth, rendererHeight );
                realityInterface.changeFrameSize(width, height);
            });
            
            realityInterface.setFullScreenOn();
            realityInterface.setMoveDelay(400);
            realityInterface.registerTouchDecider(touchDecider);
            
            // IMPORTANT: no need to separately subscribe to groundplane and modelview
            // replace addMatrixListener and addGroundPlaneMatrixListener with addAnchoredModelViewListener
            realityInterface.subscribeToAnchoredModelView();
            realityInterface.addAnchoredModelViewListener(renderScene);
        });
    });
    
    function createMesh() {
        let boxWidthMeters = 0.8;
        let boxHeightMeters = 1.5;
        let boxDepthMeters = 0.8;
        let mToUnit = 1000;
        let geometry = new THREE.BoxGeometry(boxWidthMeters * mToUnit, boxHeightMeters * mToUnit, boxDepthMeters * mToUnit);
        const palette = ['#eb0e7e']; // '#ff0077', '#0077ff', '#ff00ff', '#ff7700', '#7700ff', '#ffff00'];
        const sensorColor = palette[Math.floor(Math.random() * palette.length)];
        let material = new THREE.MeshBasicMaterial({
            color: sensorColor,
            opacity: 0.3,
            transparent: true,
        });
        mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = 0;
        mesh.position.y = boxHeightMeters / 2 * mToUnit;
        mesh.position.z = 0;
        threejsContainerObj.add( mesh );
    }
    
    function touchDecider(eventData) {
        //1. sets the mouse position with a coordinate system where the center
        //   of the screen is the origin
        mouse.x = ( eventData.x / window.innerWidth ) * 2 - 1;
        mouse.y = - ( eventData.y / window.innerHeight ) * 2 + 1;

        //2. set the picking ray from the camera position and mouse coordinates
        raycaster.setFromCamera( mouse, camera );

        //3. compute intersections
        var intersects = raycaster.intersectObjects( scene.children, true );

        return intersects.length > 0;
    }

    function setMatrixFromArray(matrix, array) {
        matrix.set( array[0], array[4], array[8], array[12],
            array[1], array[5], array[9], array[13],
            array[2], array[6], array[10], array[14],
            array[3], array[7], array[11], array[15]
        );
    }

    function renderScene(anchoredModelViewMatrix, projectionMatrix) {
        // only set the projection matrix for the camera 1 time, since it stays the same
        if (!isProjectionMatrixSet && projectionMatrix.length > 0) {
            setMatrixFromArray(camera.projectionMatrix, projectionMatrix);
            isProjectionMatrixSet = true;
        }

        if (isProjectionMatrixSet) { // don't turn into else statement, both can happen
            // update model view matrix
            setMatrixFromArray(threejsContainerObj.matrix, anchoredModelViewMatrix);
            // render the scene
            threejsContainerObj.visible = true;
            renderer.render( scene, camera );
        }
    }
</script>
</body>
</html>
